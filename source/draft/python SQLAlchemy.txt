http://www.pythondoc.com/flask-sqlalchemy/models.html
https://segmentfault.com/a/1190000004618621

relationship() 申明的字段不会作为真正的数据库字段属性


class Person(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50))
    addresses = db.relationship('Address', backref='person',
                                lazy='dynamic')

class Address(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(50))
    person_id = db.Column(db.Integer, db.ForeignKey('person.id'))

Person实体中有address这个字段，但是数据库里面没有这个字段。
声明relationship()之后，还需要在Address中申明一下关联规则
person_id = db.Column(db.Integer, db.ForeignKey('person.id'))

db.relationship('Address', backref='person',lazy='dynamic')
lazy='dynamic'表明查询并不是单纯的返回
所有数据，而是返回一个查询对象，可以过滤掉不必要的数据
比如一个人可能有多个地址，但是

backref=db.backref 这个属性就是说的在通过person查询所有的地址的时候，有多个地址也是类似的使用这种方法

user = session.query(User).filter_by(id=1).first()
    print '2:%s' % user.addresses.filter(Address.user_id == 1).all()

01
查询1:[<User:id=1,name=san.zhang>, <User:id=2,name=si.li>, <User:id=3,name=wu.wang>]
查询2:[<Address:id=1,email=123@qq.com,user_id=1>]
查询3:[<Address:id=2,email=456@qq.com,user_id=2>, <Address:id=3,email=789@qq.com,user_id=2>]
查询4:[]


02
查询1:[<User:id=1,name=san.zhang>, <User:id=2,name=si.li>, <User:id=3,name=wu.wang>]
查询2:SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id 
FROM address 
WHERE :param_1 = address.user_id
查询3:SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id 
FROM address 
WHERE :param_1 = address.user_id
查询4:SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id 
FROM address 
WHERE :param_1 = address.user_id

session.query(User).filter_by(id=1).first().addresses不再返回Address对象了，返回查询对象
要想获取值，还需要查询
print '查询1:%s' % session.query(User).all()
print '查询2:%s' % session.query(User).filter_by(id=1).first().addresses.all()
print '查询3:%s' % session.query(User).filter_by(id=2).first().addresses.all()
print '查询4:%s' % session.query(User).filter_by(id=2).first().addresses.filter_by(email='456@qq.com').all()

查询1:[<User:id=1,name=san.zhang>, <User:id=2,name=si.li>, <User:id=3,name=wu.wang>]
查询2:[<Address:id=1,email=123@qq.com,user_id=1>]
查询3:[<Address:id=2,email=456@qq.com,user_id=2>, <Address:id=3,email=789@qq.com,user_id=2>]
查询4:[<Address:id=2,email=456@qq.com,user_id=2>]
查询4说明了也可以先过滤，最后返回的结果可能就只有很少一部分

03 backref
print '查询1:%s' % session.query(Address).filter_by(id=1).first().user
查询1:<User:id=1,name=san.zhang>

no db.backref joined
2016-08-11 18:12:59,410 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-08-11 18:12:59,414 INFO sqlalchemy.engine.base.Engine SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id 
FROM address 
WHERE address.id = ?
 LIMIT ? OFFSET ?
2016-08-11 18:12:59,414 INFO sqlalchemy.engine.base.Engine (1, 1, 0)
2016-08-11 18:12:59,419 INFO sqlalchemy.engine.base.Engine SELECT user.id AS user_id, user.name AS user_name 
FROM user 
WHERE user.id = ?
2016-08-11 18:12:59,419 INFO sqlalchemy.engine.base.Engine (1,)
查询1:<User:id=1,name=san.zhang>

backref=db.backref('user', lazy='joined')
2016-08-11 18:15:05,769 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)
2016-08-11 18:15:05,777 INFO sqlalchemy.engine.base.Engine SELECT address.id AS address_id, address.email AS address_email, address.user_id AS address_user_id, user_1.id AS user_1_id, user_1.name AS user_1_name 
FROM address LEFT OUTER JOIN user AS user_1 ON user_1.id = address.user_id 
WHERE address.id = ?
 LIMIT ? OFFSET ?
2016-08-11 18:15:05,777 INFO sqlalchemy.engine.base.Engine (1, 1, 0)
查询1:<User:id=1,name=san.zhang>

